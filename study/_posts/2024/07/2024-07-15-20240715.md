---
title: "기술 면접 피드백"
layout: single
author_profile: true
tags:
  - study
  - 면접
---
요약: 잘못 말한 거, 몰랐던 거 정리

# 기술 면접 후기
오늘 면접 두 개를 봤다. 그 중에서 제대로 말하지 못했던 거랑 잘못 말한 거 중점적으로 정리

## 몰랐던 거

### 컨테이너 가상기술

운영체제 가상화 기술(vm)과 컨테이너 가상화 기술의 차이를 물었는데, 예전에 공부했었는데 말을 못했다.
찾아 보니까 vm은 게스트 os 까지 구현한 뒤 host os와 게스트 os를 하이퍼바이저를 통해 연결하는 방식이다.
컨테이너는 guest os를 빼고 커널을 통해 필요한 라이브러리 등을 경량화해서 구축한 뒤 host os와 연결한다.

### 객체 지향 프로그래밍 5원칙

SOLID는 기억은 했는데 `단일 책임 원칙`, `리스코프 치환 원칙`, `의존성 역전 원칙`, `인터페이스 분리`에 대해서만 말하고, 해당 설명도 제대로 못했다.

아래는 SOLID 원칙에 대한 설명이다.

1. **Single Responsibility Principle (SRP, 단일 책임 원칙)**
   - 클래스는 단 하나의 책임만을 가져야 한다.
   - 클래스는 하나의 기능만을 수행해야 하며, 그 기능이 변경되는 이유는 단 하나여야 한다.

2. **Open/Closed Principle (OCP, 개방-폐쇄 원칙)**
   - 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하지만, 수정에 대해서는 닫혀 있어야 한다.
   - 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 한다.

3. **Liskov Substitution Principle (LSP, 리스코프 치환 원칙)**
   - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
   - 상위 클래스의 메서드를 호출할 때 하위 클래스의 메서드가 예상 가능한 방식으로 동작해야 한다.

4. **Interface Segregation Principle (ISP, 인터페이스 분리 원칙)**
   - 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다.
   - 큰 인터페이스 보다는 여러 개의 작은 인터페이스가 낫다.

5. **Dependency Inversion Principle (DIP, 의존 역전 원칙)**
   - 고수준 모듈은 저수준 모듈의 구현 사항에 의존해서는 안 된다.
   - 두 모듈 간의 의존관계는 추상화에 의해 결정되어야 한다.
   - 구체화된 클래스에 의존하지 말고, 추상화된 인터페이스에 의존해야 한다.

### 트랜잭션 격리 레벨

해당 부분은 알고는 있는데 각기 어떤 레벨이 있는지는 유심히 살펴보지 않았다.

1. **Read Uncommitted (커밋되지 않은 읽기)**
   - 가장 낮은 격리 수준
   - 트랜잭션이 다른 트랜잭션의 변경 내용을 읽을 수 있음
   - 데이터 무결성 보장이 어려움

2. **Read Committed (커밋된 읽기)**
   - 트랜잭션이 다른 트랜잭션의 커밋된 변경 내용만 읽을 수 있음
   - 데이터 무결성은 어느 정도 보장됨
   - 일반적으로 가장 많이 사용되는 격리 수준

3. **Repeatable Read (반복 가능한 읽기)**
   - 트랜잭션 내에서 동일한 데이터를 반복해서 읽을 때 동일한 결과를 보장
   - 다른 트랜잭션의 삽입/삭제 작업은 차단됨
   - 일부 DBMS에서 Phantom Read 문제가 발생할 수 있음

4. **Serializable (직렬화 가능)**
   - 가장 높은 격리 수준
   - 트랜잭션들이 병렬로 실행되더라도 순차적으로 실행된 것과 같은 결과를 보장
   - 데이터 무결성이 완벽하게 보장되지만, 성능이 저하될 수 있음


### F expression

F expression에 대해 설명을 하긴 했는데 충분치 않았다.
F expression은 python에서 연산 작업을 거치는 게 아닌 db 레벨에서 연산을 거치는 것이다. <- 여기 까진 말함
다만 F expression은 db에서 직접 연산을 하기 때문에 race condition이 발생하지 않는다고 한다. 이건 몰랐다.

## 잘못 말한 거

### annotate vs aggregate

django orm에서 aggregate를 하는 방법에 대해 물었는데, 너무 자신만만하게 aggreagte 함수를 써버렸다.
사실 요청 사항이 유저별 글 수를 쿼리해달라는 거였기 때문에
맞게 썼다면 
`Post.objects.annotate(total_post=Count("user_id")).values("user_id")` 가 맞는데 긴장해서인지
`Post.objects.aggregate(Count("id")).values("id")` 라고 써버렸다. 사실 id 컬럼도 잘못 쓴거다.

덧붙여 `annotate`와 `aggregate`의 차이는 annotate는 개별 항목에 대한 집계를 사용할 수 있고, aggregate는 전체 row에 대한 집계를 진행할 때 쓴다.



# 총평

- 면접 난이도는 높지 않았다. 다만 긴장을 해서인지 질문의 의도를 정확히 판단하지 않고 마음만 앞서서 말을 해버렸다.
- 인덱싱을 사용하지 않고 디비 쿼리 최적화를 한 경험을 물었는데 계속 인덱싱 얘기를 하다가 나중에 역정규화 얘기를 꺼냈다. ㅋㅋㅋㅋ 좀 죄송스러웠다
- 또한 막판에 너무 긴장해서 위 경련 비스무리하게 와서 힘들었는데, 긴장 좀 덜해야겠다.