# 오늘 배운 것

## 공부한 거
### 웹 API 디자인
1. API 디자인이란 무엇인가?
- 웹 API는 HTTP 프로토콜을 사용하여 소프트웨어를 재사용 가능한 블록으로 변화시켰다.
- API는 애플리케이션을 개발하는 개발자들이 서비스를 소비할 수 있게 해주는 인터페이스이다.
- 좋은 API를 디자인하기 위해서는 인터페이스뿐만 아닌 모든 컨텍스트를 고려해야 한다.
- 파트너 API란?
    - 고객사나 파트너같이 특정 사용자에게 열어주는 API
- 개발자 경험(DX)
    - API의 개발자 경험이란 API를 사용하는 개발자들의 경험을 의미한다.
    - API 사용을 위한 등록 절차와 어떻게 API를 사용하는지에 관해 설명하는 문서화와 문제에 처했을 때 해결하는 것을 돕는 기술 지원 등을 의미한다
    - 그러나 DX라 칭해지는 주제에서 가장 공을 들여야 하는 주제인 API 디자인을 소홀히 한다면 모두 의미가 없다.
- API 디자인에 필요한 요소
    - API 디자인에 원칙이 없다면 컨텍스트에서 벗어날 가능성이 매우 크다
    - 따라서 API 디자인을 할 때는 반드시 커스터머의 측면과 프로바이더 측면으로 인터페이스의 두 가지 면을 고려해야 한다.
2. 사용자를 위한 API 디자인
- **작업 방식에 집중하면 인터페이스가 복잡해진다.**
- **데이터 모델의 노출은 프로바이더 관점이 들어갔다는 매우 명백한 징후이다.**
  - 데이터를 어떻게 조작하는지 역시 API를 통해 노출될 수 있으며, 이 또한 끔찍한 상황이다. 
- 사용자가 할 수 있는 일에 집중하면 인터페이스는 단순해진다.
- 컨슈머가 이해하고 사용하기 쉽게 해야 한다.
- API는 반드시 컨슈머의 관점에서 디자인되어야 한다.
- API를 디자인하는 도중 의도치 않게 프로바이더 관점이 내부 동작(데이터, 코드와 비즈니스 로직, 소프트웨어 아키텍처, 그리고 인적자원)을 노출할 수 있으며, 이 경우 필연ㄴ적으로 이해하기 어렵고 사용하기 어려운 API를 만들게 된다.
- API 디자인을 위한 목표 식별 과정
    - 누가 사용자인가?
    - 그들은 무엇을 할 수 있는가?
    - 그들은 그걸 어떻게 하는가?
    - 그들은 그것을 하기 위해 무엇이 필요한가?
    - 그들은 무엇을 반환받는가?
    - 입력은 어디를 통해서 들어오는가?
    - 출력은 어디에서 어떻게 쓰이는가?
- API 목표 캔버스 

| 누가  | 무엇을       | 어떻게             | 입력(원천)                             | 출력(사용처)        | 목표                                 |
|-----|-----------|-----------------|------------------------------------|----------------|------------------------------------| 
| 고객  | 상품을 구입한다  | 상품들을 검색한다.      | 카탈로그(카탈로그 관리)<br/>, 비정형 쿼리(사용자 입력) | 상품(카트에 추가된 상품) | 상품을 비정형 쿼리를 이용해서<br/> 카탈로그에서 검색한다. | 
|  |           | 상품을 카트에 추가한다.   | 상품(상품 검색),<br/>카트(사용자 소유)          |                | 상품을 카트에 추가한다.                      | 
| 관리자 | 상품을 관리한다. | 카탈로그에 상품을 추가한다. | 카탈로그(사용자 소유),<br/>상품(사용자 입력)       |                | 상품을 카탈로그에 추가한다.                    | 




## 코딩한 거
-

## 코딩 테스트
```python
# 프로그래머스 level0 - 옹알이(1)
baby_can_babbling = ["aya", "ye", "woo", "ma"]


def solution(babbling):
    answer = 0
    for ba in babbling:
        if ba:
            is_can_speak = True
            while is_can_speak:
                for can_ba in baby_can_babbling:
                    if ba.startswith(can_ba) or ba.endswith(can_ba):
                        ba = ba.replace(can_ba, "")
                    if not ba:
                        break
                is_can_speak = ba in baby_can_babbling
            if not ba:
                answer += 1
    return answer


assert solution(["aya", "yee", "u", "maa", "wyeoo"]) == 1
assert solution(["ayaye", "uuuma", "ye", "yemawoo", "ayaa"]) == 3
assert (
    solution(["ayaye", "uuuma", "ye", "yemawoo", "ayaa", "ayayemawoo", "umau", ""]) == 4
)
```
 