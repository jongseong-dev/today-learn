---
title: "2024-04-20 웹 API 디자인 3장 정리" 
layout: single
author_profile: true
tags:
  - 웹 API 디자인
  - REST API
  - resource
  - query vs path
---

REST API 개념 정리 및 디자인 방법, 내 경험 정리
# 책 정리

## 개념 짚어보기

- API의 경로란 서버상의 리소스를 식별할 수 있는 주소를 의미 -> `/products`, `/products/{product-id}`
- HTTP 메서드는 이 리소스를 가지고 무엇을 하고 싶은지 `GET /products/{product-id}`: **상품**을 **조회**하겠다.
- HTTP 상태 코드: 접수된 리퀘스트 처리가 어떻게 되어가는지를 의미 `200 OK`: 성공적으로 동작
- 리스폰스 바디는 식별된 리소스의 컨텐츠를 포함
- 리소스는 기능적 개념
- **콜렉션 리소스**는 일정한 타입의 리소스 여러개를 포함하는 리소스를 가리킴. 단순하게 콜렉션이라고 부르기도 함
  - 예를 들어 상품의 카탈로그를 콜렉션이라고 볼 수 있음. 왜냐하면 카탈로그에는 하위의 **상품**이라는 리소스를 포함하고 있기 때문
- 상품을 카탈로그에 추가한다.
  - 이때 **카탈로그**와 **상품**은 리소스이고 *추가*한다는 액션으로 볼 수 있다.
  - 이를 REST API의 형태로 나타내면 `POST /products`의 형태로 나타낼 수 있음. 
  - 카탈로그를 products 즉 상품의 컬렉션이기 때문에 복수형으로 표현했다. 상품은 특정 ID를 조회하는 것으로 봄
- 컨셉 디자인을 할 때는 **컨슈머 친화적**으로 해야 한다.
  - 리소스룰 반환할 때(response body)는 컨슈머 필요한 속성이 무엇일지 판단한다. 필요없는 속성이면 빼자. 
  - request에서 파라미터 또한 마찬가지로, 서버에서 가져올 수 있는 정보면 굳이 사용자가 요청하지 않아도 된다. 
  - 만약 API docs에 속성에 관한 정보를 만든다면 `속성 이름`, `타입`, `필수여부`, `필요한 경우 부가 설명` 등이 포함되도록 만드는 게 좋다.
- **액션 리소스는 명사로 표현되지 않는다.** 함수로 표현한다고 생각하자.
  - 예를 들어 **카트를 결제한다.** 라는 액션 리소스가 있다면, `POST /cart/checkout`으로 표현할 수 있다. 
  - 혹은 컨슈머 친화적이진 않지만 `POST /orders` 라고 할 수도 있다. 이게 친화적이지 않은 이유는 리소스가 명확하지 않기 때문이다.
  - 중요한 것은 현실 세계에서 완벽하게 컨슈머 친화적이면서 RESTful한 API는 힘들다. 따라서 선택한 뒤 그것을 왜 선택했는지에 대한 철학이 필요하다.

## REST 아키텍처 스티일 소개

- REST 아키텍처 스타일의 목표는 **효율적**이고 **확장 가능**하며 **안정적인 분산 시스템**을 구축하는 것이다.
- 다음의 여섯 가지를 충족할 필요가 있다.
  - 클라이언트 / 서버 분리
    - 클라이언트의 동작 방식과 API를 제공하는 동작 방식에 대해 분리해서 생각해야 한다. 
    - 이는 클라이언트와 서버간의 의존성이 없어야 한다는 것이다. 서버의 플랫폼 똔느 기술 변경은 클라이언트에 영향을 미치지 않는다.
  - 스테이트리스
    - 리퀘스트를 처리할 때 어떤 컨텍스트도 서버의 세션에 담지 않는다.
    - 필요한 모든 정보는 리퀘스트에 포함되어 있어야 함
  - 캐시 가능성
    - 리퀘스트에 대한 리스폰스는 저장 가능 여부(클라이언트가 동일한 요청을 다시 하지 않고 재사용할 수 있도록) 및 기간을 표시해야 한다.
  - 레이어드 시스템
    - 클라이언트는 하나의 레이어만 볼 수 있어야 한다.
    - 서버 뒷단에서 어떤 인프라가 있는지 알 필요없다.
    - 서버는 여러 계층을 둘 수 있다.
  - 코드 온 디멘드
    - 서버는 필요하다면 클라이언트에 실행 가능한 코드를 전송할 수 있다.(대표적인 예 javascript)
  - 유니폼 인터페이스
    - 모든 상호작용은 식별된 리소스의 개념에 따라 이루어져야 한다.
    - 식별된 리소스의 조작은 리소스의 상태 표현들과 표준 메서드들을 통해서만 이뤄져야 한다.
    - 상호작용은 리소싀 표현이 무엇을 의미하는 지와 이 리소스들로 무엇을 할 수 있는지 알려줄 수 있는 모든 메타데이터를 제공해야한다.

# REST API 디자인할 때 내 경험

## 액션 리소스
- 내 경험에 비췄을 때 액션 리소스는 리소스 앞에 표현했던 거 같다.
- 위에서는 `cart/checkout` 이라고 헀지만 나는 `checkout/cart` 이런 식으로 한 경우도 있었다.
  - 생각해보면 후자같이 쓴 경우에는 컬렉션 리소스의 액션 리소스를 쓰는 경우에 이렇게 표현했던 거 같다. `checkout/cart/{cart-id}`
  - 다만 생각해보니 이건 프로바이더 관점에서 API를 디자인 한 거 같다.
  - 왜냐하면 컨슈머 입장에서는 `cart/checkout`이 더 직관적이고 이해하기 쉬울 것이다.
  - 다시 디자인 한다면 아마 `cart/checkout/{cart-id}` 이런 식으로 할 것 같다.

## Path vs Query

- 이전에 기상예측 API 디자인(파트너 API)을 할 때 모델에 따라 API Path를 나눈 적이 있다.
- `weather/nwp`와 `weather/sattelite` 이런 식으로 나누었다.
- 이때 고민을 좀 했는데, query로 할 지 path로 할 지에 대한 고민이었다.
- query string은 둘다 같았던 것으로 기억한다. 예를 들면 `?lat=37.123&lon=127.123` 이런 식으로
- 이떄 path로 나누었는데, 사실 당시 선택한 이유는 기억에 남지 않지만 아마 이런 식으로 생각하지 않았나 싶다.
  - 첫 번째로 기상 예측을 컬렉션 타입으로 봤다. 즉 `weather`라는 컬렉션에 `nwp`와 `sattelite`이라는 리소스가 있다고 판단했다.
    - 이는 filtering의 개념보다는 리소**스 접근의 개념으로 생각했다.
  - 두 번째로 query로 표현할 경우 `/weather`라는 API 요청의 response에는 `nwp`와 `sattelite`이 같이 나올 것이다.
    - 이건 하나의 리소스의 형태로 나오는 응답형태는 아니라고 판단했다.
    - 또한 클라이언트는 `nwp`의 요청 주기와 `sattelite`의 요청 주기가 달랐다.
    - 클라이언트는 `weather`를 요청할 일이 거의 없었다. 그렇다면 굳이 response에 객체로 제공하는 것은 비효율적이라고 판단했다.